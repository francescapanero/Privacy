# Comparison between M_l and the expected values
M_l <- as.numeric(table(factor(dataset$frequencies, levels = 1:dataset$n)))
# PY comparison
tab <- rbind(
PY = expected_m_py(1:15, dataset$n, out_PY$par[2], out_PY$par[1]),
Data = M_l[1:15]
)
colnames(tab) <- 1:15
kable(tab, digits = 0)
check[[i]] <- frequency_check_PY(dataset$frequencies)
# Bethlehem and Skinner estimators
estim <- tau1_bs(dataset$frequencies, dataset$N)
tau1_bet[i] <- estim[1]
tau1_skin[i] <- estim[2]
tau1_np_pois[i] <- tau1_np_pois(dataset$N, dataset$n, dataset$frequencies)
# Plot estimates and confidence intervals
type <- c("PY", "DP", "B", "S")
estimates <- c(tau1_PY[i], tau1_DP[i], tau1_bet[i], tau1_skin[i])
df <- data.frame(
type = factor(type), estim = estimates,
lower_CI = c(PY_lower[i], DP_lower[i], NA, NA),
upper_CI = c(PY_upper[i], DP_upper[i], NA, NA)
)
p[[i]] <- ggplot(df, aes(type, estim))
p[[i]] <- p[[i]] + geom_pointrange(aes(ymin = lower_CI, ymax = upper_CI)) + theme_bw() +
theme(legend.position = "none") + xlab("") + ylab(expression(tau[1])) +
ggtitle(paste0("Zipf ", round(zipf_param, 2))) +
theme(plot.title = element_text(hjust = 0.5, size=30)) +
geom_hline(yintercept = dataset$true_tau1, linetype = "dotted")
}
source('2_functions')
source('2_functions.')
source('2_functions.R')
for (i in 1:length(zipf_param_list)) {
zipf_param <- zipf_param_list[i]
set.seed(123)
dataset <- dataset_creation_zipf(n = n, zipf_param = zipf_param, N = N)
K_n <- dataset$K_n
true_tau1[i] <- dataset$true_tau1
m1[i] <- dataset$m1
# PY estimation
out_PY <- max_EPPF_PY(dataset$frequencies)
tau1_PY[i] <- tau1_py(dataset$m1, dataset$n, out_PY$par[1], out_PY$par[2], dataset$N)
PY_sim <- tau1_py_sim(dataset$frequencies, out_PY$par[1], out_PY$par[2], dataset$N)
PY_lower[i] <- quantile(PY_sim, 0.01 / 2)
PY_upper[i] <- quantile(PY_sim, 1 - 0.01 / 2)
theta_MLE_PY[i] <- out_PY$par[1]
alpha_MLE_PY[i] <- out_PY$par[2]
# Dirichlet process estimation
out_DP <- max_EPPF_DP(dataset$frequencies)
tau1_DP[i] <- tau1_dp(dataset$m1, dataset$n, out_DP$par[1], dataset$N)
DP_lower[i] <- qhyper2(0.01 / 2, out_DP$par[1] + dataset$n - 1, dataset$N - dataset$n, dataset$m1)
DP_upper[i] <- qhyper2(1 - 0.01 / 2, out_DP$par[1] + dataset$n - 1, dataset$N - dataset$n, dataset$m1)
theta_MLE_DP[i] <- out_DP$par
# Comparison between M_l and the expected values
M_l <- as.numeric(table(factor(dataset$frequencies, levels = 1:dataset$n)))
# PY comparison
tab <- rbind(
PY = expected_m_py(1:15, dataset$n, out_PY$par[2], out_PY$par[1]),
Data = M_l[1:15]
)
colnames(tab) <- 1:15
kable(tab, digits = 0)
check[[i]] <- frequency_check_PY(dataset$frequencies)
# Bethlehem and Skinner estimators
estim <- tau1_bs(dataset$frequencies, dataset$N)
tau1_bet[i] <- estim[1]
tau1_skin[i] <- estim[2]
tau1_np_pois[i] <- tau1_np_pois(dataset$N, dataset$n, dataset$frequencies)
# Plot estimates and confidence intervals
type <- c("PY", "DP", "B", "S")
estimates <- c(tau1_PY[i], tau1_DP[i], tau1_bet[i], tau1_skin[i])
df <- data.frame(
type = factor(type), estim = estimates,
lower_CI = c(PY_lower[i], DP_lower[i], NA, NA),
upper_CI = c(PY_upper[i], DP_upper[i], NA, NA)
)
p[[i]] <- ggplot(df, aes(type, estim))
p[[i]] <- p[[i]] + geom_pointrange(aes(ymin = lower_CI, ymax = upper_CI)) + theme_bw() +
theme(legend.position = "none") + xlab("") + ylab(expression(tau[1])) +
ggtitle(paste0("Zipf ", round(zipf_param, 2))) +
theme(plot.title = element_text(hjust = 0.5, size=30)) +
geom_hline(yintercept = dataset$true_tau1, linetype = "dotted")
}
source('2_functions.R')
for (i in 1:length(zipf_param_list)) {
zipf_param <- zipf_param_list[i]
set.seed(123)
dataset <- dataset_creation_zipf(n = n, zipf_param = zipf_param, N = N)
K_n <- dataset$K_n
true_tau1[i] <- dataset$true_tau1
m1[i] <- dataset$m1
# PY estimation
out_PY <- max_EPPF_PY(dataset$frequencies)
tau1_PY[i] <- tau1_py(dataset$m1, dataset$n, out_PY$par[1], out_PY$par[2], dataset$N)
PY_sim <- tau1_py_sim(dataset$frequencies, out_PY$par[1], out_PY$par[2], dataset$N)
PY_lower[i] <- quantile(PY_sim, 0.01 / 2)
PY_upper[i] <- quantile(PY_sim, 1 - 0.01 / 2)
theta_MLE_PY[i] <- out_PY$par[1]
alpha_MLE_PY[i] <- out_PY$par[2]
# Dirichlet process estimation
out_DP <- max_EPPF_DP(dataset$frequencies)
tau1_DP[i] <- tau1_dp(dataset$m1, dataset$n, out_DP$par[1], dataset$N)
DP_lower[i] <- qhyper2(0.01 / 2, out_DP$par[1] + dataset$n - 1, dataset$N - dataset$n, dataset$m1)
DP_upper[i] <- qhyper2(1 - 0.01 / 2, out_DP$par[1] + dataset$n - 1, dataset$N - dataset$n, dataset$m1)
theta_MLE_DP[i] <- out_DP$par
# Comparison between M_l and the expected values
M_l <- as.numeric(table(factor(dataset$frequencies, levels = 1:dataset$n)))
# PY comparison
tab <- rbind(
PY = expected_m_py(1:15, dataset$n, out_PY$par[2], out_PY$par[1]),
Data = M_l[1:15]
)
colnames(tab) <- 1:15
kable(tab, digits = 0)
check[[i]] <- frequency_check_PY(dataset$frequencies)
# Bethlehem and Skinner estimators
estim <- tau1_bs(dataset$frequencies, dataset$N)
tau1_bet[i] <- estim[1]
tau1_skin[i] <- estim[2]
tau1_np_pois[i] <- tau1_np_pois(dataset$N, dataset$n, dataset$frequencies)
# Plot estimates and confidence intervals
type <- c("PY", "DP", "B", "S")
estimates <- c(tau1_PY[i], tau1_DP[i], tau1_bet[i], tau1_skin[i])
df <- data.frame(
type = factor(type), estim = estimates,
lower_CI = c(PY_lower[i], DP_lower[i], NA, NA),
upper_CI = c(PY_upper[i], DP_upper[i], NA, NA)
)
p[[i]] <- ggplot(df, aes(type, estim))
p[[i]] <- p[[i]] + geom_pointrange(aes(ymin = lower_CI, ymax = upper_CI)) + theme_bw() +
theme(legend.position = "none") + xlab("") + ylab(expression(tau[1])) +
ggtitle(paste0("Zipf ", round(zipf_param, 2))) +
theme(plot.title = element_text(hjust = 0.5, size=30)) +
geom_hline(yintercept = dataset$true_tau1, linetype = "dotted")
}
N=dataset$N
n=dataset$n
freq=dataset$frequencies
lambda = (N - n) / n
m <- rep(0, n)
a = data.frame(freq) %>% group_by(freq) %>% summarise(count=n())
for(j in 1:n){
if(j %in% a$freq) m[j] = a$count[match(j ,a$freq)]
}
ind_max = tail(which(m!=0), 1)
pois_par <- log(n / (2*lambda-1)) / (4*lambda)
ind = c(0:(ind_max-1))
a = sapply(ind, g_i, lambda=lambda, m=m)
sum(a)
a
ind_max
length(m)
m
lambda
N-n
i=330
(-1)^i * (i+1) * lambda^i * ppois(i-1, lambda, lower.tail=FALSE) * m[i+1]
(-1)^i * (i+1)
* m[i+1]
ppois(i-1, lambda, lower.tail=FALSE)
m[i+1]
ppois(i-1, lambda, lower.tail=FALSE) * m[i+1]
lambda^i * ppois(i-1, lambda, lower.tail=FALSE) * m[i+1]
lambda^i
g_i <- function(i, lambda, pois_param, m){
if(m[i+1] != 0)  return((-1)^i * (i+1) * lambda^i * ppois(i-1, lambda, lower.tail=FALSE) * m[i+1])
else  return(0)
}
tau1_np_pois <- function(N, n, freq){
lambda = (N - n) / n
m <- rep(0, n)
a = data.frame(freq) %>% group_by(freq) %>% summarise(count=n())
for(j in 1:n){
if(j %in% a$freq) m[j] = a$count[match(j ,a$freq)]
}
ind_max = tail(which(m!=0), 1)
pois_par <- log(n / (2*lambda-1)) / (4*lambda)
ind = c(0:(ind_max-1))
a = sapply(ind, g_i, lambda=lambda, m=m)
return(sum(a))
}
source('2_functions.R')
zipf_param_list <- c(1.25, 1.5, 1.75, 2)
for (i in 1:length(zipf_param_list)) {
zipf_param <- zipf_param_list[i]
set.seed(123)
dataset <- dataset_creation_zipf(n = n, zipf_param = zipf_param, N = N)
K_n <- dataset$K_n
true_tau1[i] <- dataset$true_tau1
m1[i] <- dataset$m1
# PY estimation
out_PY <- max_EPPF_PY(dataset$frequencies)
tau1_PY[i] <- tau1_py(dataset$m1, dataset$n, out_PY$par[1], out_PY$par[2], dataset$N)
PY_sim <- tau1_py_sim(dataset$frequencies, out_PY$par[1], out_PY$par[2], dataset$N)
PY_lower[i] <- quantile(PY_sim, 0.01 / 2)
PY_upper[i] <- quantile(PY_sim, 1 - 0.01 / 2)
theta_MLE_PY[i] <- out_PY$par[1]
alpha_MLE_PY[i] <- out_PY$par[2]
# Dirichlet process estimation
out_DP <- max_EPPF_DP(dataset$frequencies)
tau1_DP[i] <- tau1_dp(dataset$m1, dataset$n, out_DP$par[1], dataset$N)
DP_lower[i] <- qhyper2(0.01 / 2, out_DP$par[1] + dataset$n - 1, dataset$N - dataset$n, dataset$m1)
DP_upper[i] <- qhyper2(1 - 0.01 / 2, out_DP$par[1] + dataset$n - 1, dataset$N - dataset$n, dataset$m1)
theta_MLE_DP[i] <- out_DP$par
# Comparison between M_l and the expected values
M_l <- as.numeric(table(factor(dataset$frequencies, levels = 1:dataset$n)))
# PY comparison
tab <- rbind(
PY = expected_m_py(1:15, dataset$n, out_PY$par[2], out_PY$par[1]),
Data = M_l[1:15]
)
colnames(tab) <- 1:15
kable(tab, digits = 0)
check[[i]] <- frequency_check_PY(dataset$frequencies)
# Bethlehem and Skinner estimators
estim <- tau1_bs(dataset$frequencies, dataset$N)
tau1_bet[i] <- estim[1]
tau1_skin[i] <- estim[2]
tau1_np_pois[i] <- tau1_np_pois(dataset$N, dataset$n, dataset$frequencies)
# Plot estimates and confidence intervals
type <- c("PY", "DP", "B", "S")
estimates <- c(tau1_PY[i], tau1_DP[i], tau1_bet[i], tau1_skin[i])
df <- data.frame(
type = factor(type), estim = estimates,
lower_CI = c(PY_lower[i], DP_lower[i], NA, NA),
upper_CI = c(PY_upper[i], DP_upper[i], NA, NA)
)
p[[i]] <- ggplot(df, aes(type, estim))
p[[i]] <- p[[i]] + geom_pointrange(aes(ymin = lower_CI, ymax = upper_CI)) + theme_bw() +
theme(legend.position = "none") + xlab("") + ylab(expression(tau[1])) +
ggtitle(paste0("Zipf ", round(zipf_param, 2))) +
theme(plot.title = element_text(hjust = 0.5, size=30)) +
geom_hline(yintercept = dataset$true_tau1, linetype = "dotted")
}
lambda = (N - n) / n
m <- rep(0, n)
a = data.frame(freq) %>% group_by(freq) %>% summarise(count=n())
for(j in 1:n){
if(j %in% a$freq) m[j] = a$count[match(j ,a$freq)]
}
ind_max = tail(which(m!=0), 1)
pois_par <- log(n / (2*lambda-1)) / (4*lambda)
ind = c(0:(ind_max-1))
a = sapply(ind, g_i, lambda=lambda, m=m)
a
i=329
m[i]
g_i <- function(i, lambda, pois_param, m){
if(m[i+1] != 0)  return((-1)^i * exp(log((i+1)) + i * log(lambda) + log(ppois(i-1, lambda, lower.tail=FALSE)) +log(m[i+1])))
else  return(0)
}
lambda = (N - n) / n
m <- rep(0, n)
a = data.frame(freq) %>% group_by(freq) %>% summarise(count=n())
for(j in 1:n){
if(j %in% a$freq) m[j] = a$count[match(j ,a$freq)]
}
ind_max = tail(which(m!=0), 1)
pois_par <- log(n / (2*lambda-1)) / (4*lambda)
ind = c(0:(ind_max-1))
a = sapply(ind, g_i, lambda=lambda, m=m)
a
sum(a)
log(10)
log(e)
log(2.7)
source('2_functions.R')
zipf_param_list <- c(1.25, 1.5, 1.75, 2)
for (i in 1:length(zipf_param_list)) {
zipf_param <- zipf_param_list[i]
set.seed(123)
dataset <- dataset_creation_zipf(n = n, zipf_param = zipf_param, N = N)
K_n <- dataset$K_n
true_tau1[i] <- dataset$true_tau1
m1[i] <- dataset$m1
# PY estimation
out_PY <- max_EPPF_PY(dataset$frequencies)
tau1_PY[i] <- tau1_py(dataset$m1, dataset$n, out_PY$par[1], out_PY$par[2], dataset$N)
PY_sim <- tau1_py_sim(dataset$frequencies, out_PY$par[1], out_PY$par[2], dataset$N)
PY_lower[i] <- quantile(PY_sim, 0.01 / 2)
PY_upper[i] <- quantile(PY_sim, 1 - 0.01 / 2)
theta_MLE_PY[i] <- out_PY$par[1]
alpha_MLE_PY[i] <- out_PY$par[2]
# Dirichlet process estimation
out_DP <- max_EPPF_DP(dataset$frequencies)
tau1_DP[i] <- tau1_dp(dataset$m1, dataset$n, out_DP$par[1], dataset$N)
DP_lower[i] <- qhyper2(0.01 / 2, out_DP$par[1] + dataset$n - 1, dataset$N - dataset$n, dataset$m1)
DP_upper[i] <- qhyper2(1 - 0.01 / 2, out_DP$par[1] + dataset$n - 1, dataset$N - dataset$n, dataset$m1)
theta_MLE_DP[i] <- out_DP$par
# Comparison between M_l and the expected values
M_l <- as.numeric(table(factor(dataset$frequencies, levels = 1:dataset$n)))
# PY comparison
tab <- rbind(
PY = expected_m_py(1:15, dataset$n, out_PY$par[2], out_PY$par[1]),
Data = M_l[1:15]
)
colnames(tab) <- 1:15
kable(tab, digits = 0)
check[[i]] <- frequency_check_PY(dataset$frequencies)
# Bethlehem and Skinner estimators
estim <- tau1_bs(dataset$frequencies, dataset$N)
tau1_bet[i] <- estim[1]
tau1_skin[i] <- estim[2]
tau1_np_pois[i] <- tau1_np_pois(dataset$N, dataset$n, dataset$frequencies)
# Plot estimates and confidence intervals
type <- c("PY", "DP", "B", "S")
estimates <- c(tau1_PY[i], tau1_DP[i], tau1_bet[i], tau1_skin[i])
df <- data.frame(
type = factor(type), estim = estimates,
lower_CI = c(PY_lower[i], DP_lower[i], NA, NA),
upper_CI = c(PY_upper[i], DP_upper[i], NA, NA)
)
p[[i]] <- ggplot(df, aes(type, estim))
p[[i]] <- p[[i]] + geom_pointrange(aes(ymin = lower_CI, ymax = upper_CI)) + theme_bw() +
theme(legend.position = "none") + xlab("") + ylab(expression(tau[1])) +
ggtitle(paste0("Zipf ", round(zipf_param, 2))) +
theme(plot.title = element_text(hjust = 0.5, size=30)) +
geom_hline(yintercept = dataset$true_tau1, linetype = "dotted")
}
rm(list = ls())
source("2_functions.R")
library(xtable)
library(gridExtra)
library(knitr)
library(ggplot2)
library(dplyr)
library(reticulate) # Library that interface R to python
use_condaenv() # Use python anaconda
random <- import("numpy.random") # Import python libraries
dataset_creation_zipf <- function(n, zipf_param, N) {
# Old implementation using truncated zipf laws
# probs <- 1 / (1:H)^(zipf_param)
# points_full <- factor(sample(1:H, N, prob = probs, replace = TRUE), levels = 1:H)
# Using python zipf sampler
points_full <- factor(random$zipf(zipf_param, N))
points_obs <- sample(points_full, n, replace = FALSE)
# Observed frequencies
freq_full <- as.numeric(table(points_full))
freq_observed <- as.numeric(table(points_obs))
# True tau1
true_tau1 <- sum((freq_full == 1) & (freq_observed == 1))
freq_observed <- freq_observed[freq_observed > 0]
list(
frequencies = freq_observed, n = sum(freq_observed), N = sum(freq_full),
K_n = sum(freq_observed > 0), K_N = sum(freq_full > 0),
m1 = sum(freq_observed == 1), percentage = n / N, zipf_param = zipf_param, true_tau1 = true_tau1
)
}
dataset_creation_geom <- function(n, N, p) {
points_full <- factor(rgeom(N, p = p))
points_obs <- sample(points_full, n, replace = FALSE)
# Observed frequencies
freq_full <- as.numeric(table(points_full))
freq_observed <- as.numeric(table(points_obs))
# True tau1
true_tau1 <- sum((freq_full == 1) & (freq_observed == 1))
freq_observed <- freq_observed[freq_observed > 0]
list(
frequencies = freq_observed, n = sum(freq_observed), N = sum(freq_full),
K_n = sum(freq_observed > 0), K_N = sum(freq_full > 0),
m1 = sum(freq_observed == 1), percentage = n / N, true_tau1 = true_tau1
)
}
dataset_creation_probs <- function(n, N, probs) {
# Old implementation using truncated zipf laws
H <- length(probs)
points_full <- factor(sample(1:H, N, prob = probs, replace = TRUE))
points_obs <- sample(points_full, n, replace = FALSE)
# Observed frequencies
freq_full <- as.numeric(table(points_full))
freq_observed <- as.numeric(table(points_obs))
# True tau1
true_tau1 <- sum((freq_full == 1) & (freq_observed == 1))
freq_observed <- freq_observed[freq_observed > 0]
list(
frequencies = freq_observed, n = sum(freq_observed), N = sum(freq_full),
K_n = sum(freq_observed > 0), K_N = sum(freq_full > 0),
m1 = sum(freq_observed == 1), percentage = n / N, true_tau1 = true_tau1
)
}
N <- 1000000L # Important to us L, otherwise is not recognized as integer
n <- 100000L
p <- list()
check <- list()
true_tau1 = m1 <- c()
tau1_bet = tau1_skin = tau1_PY = tau1_DP = tau1_np_pois <- c()
PY_lower = PY_upper = DP_lower = DP_upper <- c()
theta_MLE_PY = alpha_MLE_PY = theta_MLE_DP <- c()
zipf_param_list <- c(1.25, 1.5, 1.75, 2)
for (i in 1:length(zipf_param_list)) {
zipf_param <- zipf_param_list[i]
set.seed(123)
dataset <- dataset_creation_zipf(n = n, zipf_param = zipf_param, N = N)
K_n <- dataset$K_n
true_tau1[i] <- dataset$true_tau1
m1[i] <- dataset$m1
# PY estimation
out_PY <- max_EPPF_PY(dataset$frequencies)
tau1_PY[i] <- tau1_py(dataset$m1, dataset$n, out_PY$par[1], out_PY$par[2], dataset$N)
PY_sim <- tau1_py_sim(dataset$frequencies, out_PY$par[1], out_PY$par[2], dataset$N)
PY_lower[i] <- quantile(PY_sim, 0.01 / 2)
PY_upper[i] <- quantile(PY_sim, 1 - 0.01 / 2)
theta_MLE_PY[i] <- out_PY$par[1]
alpha_MLE_PY[i] <- out_PY$par[2]
# Dirichlet process estimation
out_DP <- max_EPPF_DP(dataset$frequencies)
tau1_DP[i] <- tau1_dp(dataset$m1, dataset$n, out_DP$par[1], dataset$N)
DP_lower[i] <- qhyper2(0.01 / 2, out_DP$par[1] + dataset$n - 1, dataset$N - dataset$n, dataset$m1)
DP_upper[i] <- qhyper2(1 - 0.01 / 2, out_DP$par[1] + dataset$n - 1, dataset$N - dataset$n, dataset$m1)
theta_MLE_DP[i] <- out_DP$par
# Comparison between M_l and the expected values
M_l <- as.numeric(table(factor(dataset$frequencies, levels = 1:dataset$n)))
# PY comparison
tab <- rbind(
PY = expected_m_py(1:15, dataset$n, out_PY$par[2], out_PY$par[1]),
Data = M_l[1:15]
)
colnames(tab) <- 1:15
kable(tab, digits = 0)
check[[i]] <- frequency_check_PY(dataset$frequencies)
# Bethlehem and Skinner estimators
estim <- tau1_bs(dataset$frequencies, dataset$N)
tau1_bet[i] <- estim[1]
tau1_skin[i] <- estim[2]
tau1_np_pois[i] <- tau1_np_pois(dataset$N, dataset$n, dataset$frequencies)
# Plot estimates and confidence intervals
type <- c("PY", "DP", "B", "S")
estimates <- c(tau1_PY[i], tau1_DP[i], tau1_bet[i], tau1_skin[i])
df <- data.frame(
type = factor(type), estim = estimates,
lower_CI = c(PY_lower[i], DP_lower[i], NA, NA),
upper_CI = c(PY_upper[i], DP_upper[i], NA, NA)
)
p[[i]] <- ggplot(df, aes(type, estim))
p[[i]] <- p[[i]] + geom_pointrange(aes(ymin = lower_CI, ymax = upper_CI)) + theme_bw() +
theme(legend.position = "none") + xlab("") + ylab(expression(tau[1])) +
ggtitle(paste0("Zipf ", round(zipf_param, 2))) +
theme(plot.title = element_text(hjust = 0.5, size=30)) +
geom_hline(yintercept = dataset$true_tau1, linetype = "dotted")
}
source('2_functions.R')
for (i in 1:length(zipf_param_list)) {
zipf_param <- zipf_param_list[i]
set.seed(123)
dataset <- dataset_creation_zipf(n = n, zipf_param = zipf_param, N = N)
K_n <- dataset$K_n
true_tau1[i] <- dataset$true_tau1
m1[i] <- dataset$m1
# PY estimation
out_PY <- max_EPPF_PY(dataset$frequencies)
tau1_PY[i] <- tau1_py(dataset$m1, dataset$n, out_PY$par[1], out_PY$par[2], dataset$N)
PY_sim <- tau1_py_sim(dataset$frequencies, out_PY$par[1], out_PY$par[2], dataset$N)
PY_lower[i] <- quantile(PY_sim, 0.01 / 2)
PY_upper[i] <- quantile(PY_sim, 1 - 0.01 / 2)
theta_MLE_PY[i] <- out_PY$par[1]
alpha_MLE_PY[i] <- out_PY$par[2]
# Dirichlet process estimation
out_DP <- max_EPPF_DP(dataset$frequencies)
tau1_DP[i] <- tau1_dp(dataset$m1, dataset$n, out_DP$par[1], dataset$N)
DP_lower[i] <- qhyper2(0.01 / 2, out_DP$par[1] + dataset$n - 1, dataset$N - dataset$n, dataset$m1)
DP_upper[i] <- qhyper2(1 - 0.01 / 2, out_DP$par[1] + dataset$n - 1, dataset$N - dataset$n, dataset$m1)
theta_MLE_DP[i] <- out_DP$par
# Comparison between M_l and the expected values
M_l <- as.numeric(table(factor(dataset$frequencies, levels = 1:dataset$n)))
# PY comparison
tab <- rbind(
PY = expected_m_py(1:15, dataset$n, out_PY$par[2], out_PY$par[1]),
Data = M_l[1:15]
)
colnames(tab) <- 1:15
kable(tab, digits = 0)
check[[i]] <- frequency_check_PY(dataset$frequencies)
# Bethlehem and Skinner estimators
estim <- tau1_bs(dataset$frequencies, dataset$N)
tau1_bet[i] <- estim[1]
tau1_skin[i] <- estim[2]
tau1_np_pois[i] <- tau1_np_pois(dataset$N, dataset$n, dataset$frequencies)
# Plot estimates and confidence intervals
type <- c("PY", "DP", "B", "S")
estimates <- c(tau1_PY[i], tau1_DP[i], tau1_bet[i], tau1_skin[i])
df <- data.frame(
type = factor(type), estim = estimates,
lower_CI = c(PY_lower[i], DP_lower[i], NA, NA),
upper_CI = c(PY_upper[i], DP_upper[i], NA, NA)
)
p[[i]] <- ggplot(df, aes(type, estim))
p[[i]] <- p[[i]] + geom_pointrange(aes(ymin = lower_CI, ymax = upper_CI)) + theme_bw() +
theme(legend.position = "none") + xlab("") + ylab(expression(tau[1])) +
ggtitle(paste0("Zipf ", round(zipf_param, 2))) +
theme(plot.title = element_text(hjust = 0.5, size=30)) +
geom_hline(yintercept = dataset$true_tau1, linetype = "dotted")
}
i
N=dataset$N
n=dataset$n
freq=dataset$frequencies
lambda = (N - n) / n
m <- rep(0, n)
a = data.frame(freq) %>% group_by(freq) %>% summarise(count=n())
for(j in 1:n){
if(j %in% a$freq) m[j] = a$count[match(j ,a$freq)]
}
m
ind_max = tail(which(m!=0), 1)
pois_par <- log(n / (2*lambda-1)) / (4*lambda)
ind = c(0:(ind_max-1))
pois_param <- log(n / (2*lambda-1)) / (4*lambda)
ind = c(0:(ind_max-1))
a = sapply(ind, g_i, pois_param=pois_param, m=m)
a = sapply(ind, g_i, pois_param=pois_param, lambda=lambda, m=m)
sum(a)
