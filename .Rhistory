x <- y <- seq(-5, 5, length= 40)
z <- outer(x, y, lik)
persp(x, y, z)
par(mfrow=c(1,1))
persp(x, y, z)
persp(x, y, z, col = "springgreen", shade = 0.5)
# -------
# Ex 4
# -------
library(plotly)
install.packages('plotly')
# -------
# Ex 4
# -------
library(plotly)
fig <- plot_ly(z = z)
fig <- fig %>% add_surface()
fig
x <- y <- seq(-10, 10, length= 40)
x
z <- outer(x, y, lik)
par(mfrow=c(1,1))
fig <- plot_ly(z = z)
fig <- fig %>% add_surface()
fig
DP <- deviance(sqrtl.glm)
DR <- deviance(sqrtlR.glm)
x
# x <- seq(-10, 10, length= 40)
x <- 0
y <- seq(-10, 10, length= 40)
z <- outer(x, y, lik)
par(mfrow=c(1,1))
fig <- plot_ly(z = z)
fig <- fig %>% add_surface()
fig
plot(y,z)
# x <- seq(-10, 10, length= 40)
x <- 10
y <- seq(-10, 10, length= 40)
z <- outer(x, y, lik)
plot(y,z)
# x <- seq(-10, 10, length= 40)
x <- seq(-10, 10, length= 40)
y <- seq(-10, 10, length= 40)
z <- outer(x, y, lik)
par(mfrow=c(1,1))
fig <- plot_ly(z = z)
fig <- fig %>% add_surface()
fig
x<10
x=10
z <- outer(x, y, lik)
plot(z)
y
x
z <- outer(x, y, lik)
z
plot(y,z)
# x <- seq(-10, 10, length= 40)
x <- seq(-10, 10, length= 40)
x
z <- outer(x, y, lik)
z[10,]
# x <- seq(-10, 10, length= 40)
x <- seq(-10, 10, length= 40)
y <- seq(-10, 10, length= 40)
z <- outer(x, y, lik)
par(mfrow=c(1,1))
fig <- plot_ly(z = z)
fig <- fig %>% add_surface()
fig
# x <- seq(-10, 10, length= 40)
x <- seq(-20, 20, length= 60)
y <- seq(-20, 20, length= 60)
z <- outer(x, y, lik)
par(mfrow=c(1,1))
fig <- plot_ly(z = z)
fig <- fig %>% add_surface()
fig
fig.update_xaxes(autorange="reversed")
fig.update_scenes(xaxis_autorange="reversed")
# ------
# Ex 1
# ------
disease <- c(77,19,47,48,16,31)
healthy <- c(381,128,447,336,111,433)
gender <- c('M','M','M','F','F','F')
feed <- c('Bottle','Suppl','Breast','Bottle','Suppl','Breast') m <- disease + healthy
y <- disease
m <- disease + healthy
y <- disease
(X <- model.matrix(cbind(disease,healthy) ~ gender + feed))
feed <- c('Bottle','Suppl','Breast','Bottle','Suppl','Breast')
m <- disease + healthy
y <- disease
(X <- model.matrix(cbind(disease,healthy) ~ gender + feed))
# IRLS - initialise using mu=y (>0) and formulae from Sheet 3, question 1
mu <- y
eta <- log(mu/(m-mu))
z <- eta
W <- diag(c(mu*(m-mu)/m))
k <- 1
dif <- 1
beta <- solve(t(X)%*%W%*%X) %*% t(X)%*%W%*%z
while((k < 1000) && (dif>1e-05)){ k <- k+1
betao <- beta
# update eta, mu, W and z
eta <- X %*% beta
mu <- m*exp(eta)/(1+exp(eta))
W <- diag(c(mu*(m-mu)/m))
z <- eta + m*(y-mu)/(mu*(m-mu))
beta <- solve(t(X)%*%W%*%X) %*% t(X)%*%W%*%z
dif <- max(abs(betao-beta)) }
k
dif
# MLE
beta
# Fisher information
eta <- X %*% beta
mu <- m*exp(eta)/(1+exp(eta))
W <- diag(c(mu*(m-mu)/m))
Iinv <- solve(t(X)%*%W%*%X)
# standard errors
sqrt(diag(Iinv))
# ----------------------
# Ex 2
# ----------------------
# part b)
aids <- read.csv("http://www.stats.ox.ac.uk/~laws/SB1/data/aids.csv")
head(aids)
aids$qrt <- as.factor(aids$qrt)
plot(cases ~ date, data=aids)
logl.glm <- glm(cases ~ date + qrt, data=aids, family=poisson)
summary(logl.glm)
sqrtl.glm <- glm(cases ~ date + qrt, data=aids, family=poisson(link=sqrt))
summary(sqrtl.glm) # sqrt looks better
par(mfrow=c(1,2))
plot(cases ~ date, data=aids)
points(predict(logl.glm,type="response") ~ date, data=aids, pch=16)
plot(cases ~ date, data=aids)
points(predict(sqrtl.glm,type="response") ~ date, data=aids, pch=16) # sqrt looks better
# part c)
sqrtlR.glm <- glm(cases ~ date, data=aids, family=poisson(link=sqrt))
DP <- deviance(sqrtl.glm)
DR <- deviance(sqrtlR.glm)
LRT <- DR-DP
p <- sqrtl.glm$rank
r <- sqrtlR.glm$rank
c(DP,DR,LRT,p,r)
1-pchisq(LRT,p-r) # qrt significant
# otherwise
anova(sqrtl.glm, test="Chisq") # qrt significant
# part d)
n <- nrow(model.frame(sqrtl.glm))
par(mfrow=c(1,2))
plot(fitted(sqrtl.glm),rstandard(sqrtl.glm)) # there's a pattern!
plot(cooks.distance(sqrtl.glm)) # many points with large influence
abline(h=8/(n-2*p), lty=2) # threshold high influence
library(plotly)
lik <- function(x, y){
(1+exp(x+y))*(1+exp(x+2*y))*(1+exp(x+3*y))*(1+exp(x+4*y))/((1+exp(x+y))*(1+exp(x+2*y))*(1+exp(x+3*y))*
(1+exp(x+4*y))*(1+exp(x-y))*(1+exp(x-2*y))*
(1+exp(x-3*y))*(1+exp(x-4*y)))
}
lik <- function(x, y) (1+exp(x+y))*(1+exp(x+2*y))*(1+exp(x+3*y))*(1+exp(x+4*y))/((1+exp(x+y))*(1+exp(x+2*y))*(1+exp(x+3*y))*
(1+exp(x+4*y))*(1+exp(x-y))*(1+exp(x-2*y))*
(1+exp(x-3*y))*(1+exp(x-4*y)))
x <- seq(-20, 20, length= 60)
y <- seq(-20, 20, length= 60)
z <- outer(x, y, lik)
par(mfrow=c(1,1))
fig <- plot_ly(z = z)
fig <- fig %>% add_surface()
fig
y[60]
x = 0
y <- seq(-20, 20, length= 60)
z <- outer(x, y, lik)
plot(y,z)
x = -5
y <- seq(-20, 20, length= 60)
z <- outer(x, y, lik)
plot(y,z)
x = -10
y <- seq(-20, 20, length= 60)
z <- outer(x, y, lik)
plot(y,z)
x = 10
y <- seq(-20, 20, length= 60)
z <- outer(x, y, lik)
plot(y,z)
x = -50
y <- seq(-20, 20, length= 60)
z <- outer(x, y, lik)
plot(y,z)
x <- seq(-20, 20, length= 60)
y <- seq(-20, 20, length= 60)
z <- outer(x, y, lik)
fig <- plot_ly(z = z)
fig <- fig %>% add_surface()
fig
x = 10
y <- seq(-20, 20, length= 60)
z <- outer(x, y, lik)
plot(y,z)
disease <- c(77,19,47,48,16,31)
healthy <- c(381,128,447,336,111,433)
gender <- c('M','M','M','F','F','F')
feed <- c('Bottle','Suppl','Breast','Bottle','Suppl','Breast')
m <- disease + healthy
y <- disease
(X <- model.matrix(cbind(disease,healthy) ~ gender + feed))
# IRLS - initialize using mu=y (>0) and formulae from PS3 Q1
mu <- y
eta <- log(mu/(m-mu))
z <- eta
W <- diag(c(mu*(m-mu)/m))
k <- 1
dif <- 1
beta <- solve(t(X)%*%W%*%X) %*% t(X)%*%W%*%z
# IRLS - iterations
while((k < 1000) && (dif>1e-05)){
k <- k+1
betao <- beta
# update eta, mu, W and z
eta <- X %*% beta
mu <- m*exp(eta)/(1+exp(eta))
W <- diag(c(mu*(m-mu)/m))
z <- eta + m*(y-mu)/(mu*(m-mu))
beta <- solve(t(X)%*%W%*%X) %*% t(X)%*%W%*%z
dif <- max(abs(betao-beta))
}
k
dif
# MLE
beta
# Fisher information
eta <- X %*% beta
mu <- m*exp(eta)/(1+exp(eta))
W <- diag(c(mu*(m-mu)/m))
Iinv <- solve(t(X)%*%W%*%X)
# standard errors
sqrt(diag(Iinv))
# part b)
aids <- read.csv("http://www.stats.ox.ac.uk/~laws/SB1/data/aids.csv")
head(aids)
aids$qrt <- as.factor(aids$qrt)
plot(cases ~ date, data=aids)
logl.glm <- glm(cases ~ date + qrt, data=aids, family=poisson)
summary(logl.glm)
sqrtl.glm <- glm(cases ~ date + qrt, data=aids, family=poisson(link=sqrt))
summary(sqrtl.glm) # sqrt looks better for resid deviance and AIC
par(mfrow=c(1,2))
plot(cases ~ date, data=aids)
points(predict(logl.glm,type="response") ~ date, data=aids, pch=16)
plot(cases ~ date, data=aids)
points(predict(sqrtl.glm,type="response") ~ date, data=aids, pch=16) # sqrt looks better
# part c)
sqrtlR.glm <- glm(cases ~ date, data=aids, family=poisson(link=sqrt))
DP <- deviance(sqrtl.glm)
DR <- deviance(sqrtlR.glm)
LRT <- DR-DP
p <- sqrtl.glm$rank
r <- sqrtlR.glm$rank
c(DP,DR,LRT,p,r)
1-pchisq(LRT,p-r) # qrt significant
# otherwise
anova(sqrtl.glm, test="Chisq") # qrt significant
# part d)
n <- nrow(model.frame(sqrtl.glm))
par(mfrow=c(1,2))
plot(fitted(sqrtl.glm),rstandard(sqrtl.glm)) # there's a pattern!
plot(cooks.distance(sqrtl.glm)) # many points with large influence
abline(h=8/(n-2*p), lty=2) # threshold high influence
library(plotly)
par(mfrow=c(1,1))
lik <- function(x, y) (1+exp(x+y))*(1+exp(x+2*y))*(1+exp(x+3*y))*(1+exp(x+4*y))/((1+exp(x+y))*(1+exp(x+2*y))*(1+exp(x+3*y))*
(1+exp(x+4*y))*(1+exp(x-y))*(1+exp(x-2*y))*
(1+exp(x-3*y))*(1+exp(x-4*y)))
x <- seq(-20, 20, length= 60)
y <- seq(-20, 20, length= 60)
z <- outer(x, y, lik)
fig <- plot_ly(z = z)
fig <- fig %>% add_surface()
fig # axes x and y are inverted
# extract data
library(MASS)
data(hills)
hills
# let's transform climb following the exercize: climb <- climb/1000
# This won't really affect the estimates cause it's just a linear transformation of x, so it's not a big deal
hills$climb <- hills$climb/1000
# Let's draw some exploratory plots
# distance vs time
plot(hills$dist, hills$time, xlab='distance', ylab='time')
text(hills$dist, hills$time, labels=rownames(hills), cex=0.7, font=1)
# climb vs time
plot(hills$climb, hills$time, xlab='climb', ylab='sqrt time')
text(hills$climb, hills$time, labels=rownames(hills), cex=0.7, font=1)
# Since we have this information, I will correct Knock Hill before proceeeding.
hills[18,3] <- 18.650
# Now, let's estimate our first linear model (warning: it is not the same of the exercize)
lm1 <- lm(time ~ dist + climb, data=hills)
summary(lm1)
t=-12.9420/2.5801
t
?pnorm
1-1*pnorm(t)
1-2*pnorm(t)
2*pnorm(t)
pnorm(t)
t
2*pt(t)
?pt
length(hills)
size(hills)
dim(hills)
2*pt(t, dim(hills)[0]-1)
dim(hills)[0]-1
2*pt(t, dim(hills)[1]-1)
1-2*pt(t, dim(hills)[1]-1)
2*(1-pt(t, dim(hills)[1]-1))
1-pt(t, dim(hills)[1]-1)
1-2*pt(|t|, dim(hills)[1]-1)
1-2*pt(-t, dim(hills)[1]-1)
pt(t, dim(hills)[1]-1)
2*pt(t, dim(hills)[1]-1)
1-pt(-t, dim(hills)[1]-1)
1-2*pt(-t, dim(hills)[1]-1)
1-2*pt(t, dim(hills)[1]-1)
2*pt(t, dim(hills)[1]-1)
2*pt(t, dim(hills)[1]-3)
rm(list = ls())
setwd("~/Documents/Privacy_git/Privacy")
source("2_functions.R")
library(gridExtra)
library(knitr)
library(ggplot2)
library(dplyr)
library(reticulate) # Library that interface R to python
use_condaenv() # Use python anaconda
random <- import("numpy.random") # Import python libraries
dataset_creation_zipf <- function(n, zipf_param, N) {
# Old implementation using truncated zipf laws
# probs <- 1 / (1:H)^(zipf_param)
# points_full <- factor(sample(1:H, N, prob = probs, replace = TRUE), levels = 1:H)
# Using python zipf sampler
points_full <- factor(random$zipf(zipf_param, N))
points_obs <- sample(points_full, n, replace = FALSE)
# Observed frequencies
freq_full <- as.numeric(table(points_full))
freq_observed <- as.numeric(table(points_obs))
# True tau1
true_tau1 <- sum((freq_full == 1) & (freq_observed == 1))
freq_observed <- freq_observed[freq_observed > 0]
list(
frequencies = freq_observed, n = sum(freq_observed), N = sum(freq_full),
K_n = sum(freq_observed > 0), K_N = sum(freq_full > 0),
m1 = sum(freq_observed == 1), percentage = n / N, zipf_param = zipf_param, true_tau1 = true_tau1
)
}
dataset_creation_geom <- function(n, N, p) {
points_full <- factor(rgeom(N, p = p))
points_obs <- sample(points_full, n, replace = FALSE)
# Observed frequencies
freq_full <- as.numeric(table(points_full))
freq_observed <- as.numeric(table(points_obs))
# True tau1
true_tau1 <- sum((freq_full == 1) & (freq_observed == 1))
freq_observed <- freq_observed[freq_observed > 0]
list(
frequencies = freq_observed, n = sum(freq_observed), N = sum(freq_full),
K_n = sum(freq_observed > 0), K_N = sum(freq_full > 0),
m1 = sum(freq_observed == 1), percentage = n / N, true_tau1 = true_tau1
)
}
dataset_creation_probs <- function(n, N, probs) {
# Old implementation using truncated zipf laws
H <- length(probs)
points_full <- factor(sample(1:H, N, prob = probs, replace = TRUE))
points_obs <- sample(points_full, n, replace = FALSE)
# Observed frequencies
freq_full <- as.numeric(table(points_full))
freq_observed <- as.numeric(table(points_obs))
# True tau1
true_tau1 <- sum((freq_full == 1) & (freq_observed == 1))
freq_observed <- freq_observed[freq_observed > 0]
list(
frequencies = freq_observed, n = sum(freq_observed), N = sum(freq_full),
K_n = sum(freq_observed > 0), K_N = sum(freq_full > 0),
m1 = sum(freq_observed == 1), percentage = n / N, true_tau1 = true_tau1
)
}
N <- 1000000L # Use L, otherwise is not recognized as integer
n <- 100000L
# List of potential parameters
zipf_param_list <- c(1.0526, 1.1765, 1.3333, 1.5385, 1.8182, 2.2222, 2.8571, 4)
zipf_param <- zipf_param_list[1]
set.seed(123)
dataset <- dataset_creation_zipf(n = n, zipf_param = zipf_param, N = N)
out_PY <- max_EPPF_PY(dataset$frequencies)
# plot together
N <- 1000000L # Important to us L, otherwise is not recognized as integer
n <- 100000L
p <- list()
check <- list()
K_n <- c()
tau1_bet <- c()
tau1_skin <- c()
tau1_PY <- c()
tau1_DP  <- c()
PY_lower <- c()
PY_upper <- c()
DP_lower <- c()
DP_upper <- c()
true_tau1 <- c()
m1 <- c()
out_PY <- list()
dataset <- list()
zipf_param_list <- c(1.0526, 1.1765, 1.3333, 1.5385, 1.8182, 2.2222, 2.8571, 4)
for (i in 1:length(zipf_param_list)) {
zipf_param <- zipf_param_list[i]
set.seed(123)
dataset[[i]] <- dataset_creation_zipf(n = n, zipf_param = zipf_param, N = N)
K_n[i] = dataset[[i]]$K_n
true_tau1[i] = dataset[[i]]$true_tau1
m1[i] <- dataset[[i]]$m1
# # Comparison between M_l and the expected values
# M_l <- as.numeric(table(factor(dataset[[i]]$frequencies, levels = 1:dataset[[i]]$n)))
# # PY comparison
# tab <- rbind(
#   PY = expected_m_py(1:15, dataset[[i]]$n, out_PY$par[2], out_PY$par[1]),
#   Data = M_l[1:15]
# )
# colnames(tab) <- 1:15
# kable(tab, digits = 0)
# check[[i]] <- frequency_check_PY(dataset[[i]]$frequencies)
# PY estimation
out_PY[[i]] <- max_EPPF_PY(dataset[[i]]$frequencies)
tau1_PY[i] <- tau1_py(dataset[[i]]$m1, dataset[[i]]$n, out_PY[[i]]$par[1], out_PY[[i]]$par[2], dataset[[i]]$N)
PY_sim <- tau1_py_sim(dataset[[i]]$frequencies, out_PY[[i]]$par[1], out_PY[[i]]$par[2], dataset[[i]]$N)
PY_lower[i] <- quantile(PY_sim, 0.01 / 2)
PY_upper[i] <- quantile(PY_sim, 1 - 0.01 / 2)
# Dirichlet process estimation
out_DP[[i]] <- max_EPPF_DP(dataset[[i]]$frequencies)
tau1_DP[i] <- tau1_dp(dataset[[i]]$m1, dataset[[i]]$n, out_DP[[i]]$par[1], dataset[[i]]$N)
DP_lower[i] <- qhyper(0.01 / 2, out_DP[[i]]$par[1] + dataset[[i]]$n - 1, dataset[[i]]$N - dataset[[i]]$n, dataset[[i]]$m1)
DP_upper[i] <- qhyper(1 - 0.01 / 2, out_DP[[i]]$par[1] + dataset[[i]]$n - 1, dataset[[i]]$N - dataset[[i]]$n, dataset[[i]]$m1)
# Bethlehem and Skinner estimators
estim <- tau1_bs(dataset[[i]]$frequencies, dataset[[i]]$N)
tau1_bet[i] <- estim[1]
tau1_skin[i] <- estim[2]
# Plot estimates and confidence intervals
type <- c("PY", "DP", "B", "S")
estimates <- c(tau1_PY[i], tau1_DP[i], tau1_bet[i], tau1_skin[i])
df <- data.frame(
type = factor(type), estim = estimates,
lower_CI = c(PY_lower[i], DP_lower[i], NA, NA),
upper_CI = c(PY_upper[i], DP_upper[i], NA, NA)
)
p[[i]] <- ggplot(df, aes(type, estim, color = type))
p[[i]] <- p[[i]] + geom_pointrange(aes(ymin = lower_CI, ymax = upper_CI)) +  theme_bw() +
theme(legend.position = "none") + xlab("") + ylab(expression(tau[1])) + ggtitle(paste0("Zipf parameter: ", round(zipf_param, 2)))  + theme(plot.title = element_text(hjust = 0.5)) + geom_hline(yintercept = dataset$true_tau1, linetype="dotted")
}
out_DP <- list()
dataset <- list()
zipf_param_list <- c(1.0526, 1.1765, 1.3333, 1.5385, 1.8182, 2.2222, 2.8571, 4)
for (i in 1:length(zipf_param_list)) {
zipf_param <- zipf_param_list[i]
set.seed(123)
dataset[[i]] <- dataset_creation_zipf(n = n, zipf_param = zipf_param, N = N)
K_n[i] = dataset[[i]]$K_n
true_tau1[i] = dataset[[i]]$true_tau1
m1[i] <- dataset[[i]]$m1
# # Comparison between M_l and the expected values
# M_l <- as.numeric(table(factor(dataset[[i]]$frequencies, levels = 1:dataset[[i]]$n)))
# # PY comparison
# tab <- rbind(
#   PY = expected_m_py(1:15, dataset[[i]]$n, out_PY$par[2], out_PY$par[1]),
#   Data = M_l[1:15]
# )
# colnames(tab) <- 1:15
# kable(tab, digits = 0)
# check[[i]] <- frequency_check_PY(dataset[[i]]$frequencies)
# PY estimation
out_PY[[i]] <- max_EPPF_PY(dataset[[i]]$frequencies)
tau1_PY[i] <- tau1_py(dataset[[i]]$m1, dataset[[i]]$n, out_PY[[i]]$par[1], out_PY[[i]]$par[2], dataset[[i]]$N)
PY_sim <- tau1_py_sim(dataset[[i]]$frequencies, out_PY[[i]]$par[1], out_PY[[i]]$par[2], dataset[[i]]$N)
PY_lower[i] <- quantile(PY_sim, 0.01 / 2)
PY_upper[i] <- quantile(PY_sim, 1 - 0.01 / 2)
# Dirichlet process estimation
out_DP[[i]] <- max_EPPF_DP(dataset[[i]]$frequencies)
tau1_DP[i] <- tau1_dp(dataset[[i]]$m1, dataset[[i]]$n, out_DP[[i]]$par[1], dataset[[i]]$N)
DP_lower[i] <- qhyper(0.01 / 2, out_DP[[i]]$par[1] + dataset[[i]]$n - 1, dataset[[i]]$N - dataset[[i]]$n, dataset[[i]]$m1)
DP_upper[i] <- qhyper(1 - 0.01 / 2, out_DP[[i]]$par[1] + dataset[[i]]$n - 1, dataset[[i]]$N - dataset[[i]]$n, dataset[[i]]$m1)
# Bethlehem and Skinner estimators
estim <- tau1_bs(dataset[[i]]$frequencies, dataset[[i]]$N)
tau1_bet[i] <- estim[1]
tau1_skin[i] <- estim[2]
# Plot estimates and confidence intervals
type <- c("PY", "DP", "B", "S")
estimates <- c(tau1_PY[i], tau1_DP[i], tau1_bet[i], tau1_skin[i])
df <- data.frame(
type = factor(type), estim = estimates,
lower_CI = c(PY_lower[i], DP_lower[i], NA, NA),
upper_CI = c(PY_upper[i], DP_upper[i], NA, NA)
)
p[[i]] <- ggplot(df, aes(type, estim, color = type))
p[[i]] <- p[[i]] + geom_pointrange(aes(ymin = lower_CI, ymax = upper_CI)) +  theme_bw() +
theme(legend.position = "none") + xlab("") + ylab(expression(tau[1])) + ggtitle(paste0("Zipf parameter: ", round(zipf_param, 2)))  + theme(plot.title = element_text(hjust = 0.5)) + geom_hline(yintercept = dataset$true_tau1, linetype="dotted")
}
